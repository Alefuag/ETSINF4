
0MBEGIN-ENTRY-MAIN

HELP_USAGE                 FUNCTION_SUMMARY
RELEASE_NOTES              COMMAND_SUMMARY
CONSTRUCT_SUMMARY          INTEGRATED_EDITOR

END-ENTRY

1IBEGIN-ENTRY-HELP_USAGE

HELP_USAGE

H.2 Using the Help Facility
The help facility displays menus of topics and prompts the user for a choice.  
It then references the help file for that information.  The help facility can 
be called with or without a command-line topic.

Syntax:
   (help [<path>])

where <path> is the full path leading to a topic in the help tree.  For 
example, for information on defrule syntax, the user would type:  
   (help construct_summary defrule).  
The help function has no return value.

Each element or field in the path is delimited by white space, and the help 
facility is not case sensitive.  In addition, the entire name of a field does  
not need to be specified.  Only enough characters to distinguish the field 
from other choices in the menu are necessary (if there is a conflict, the help  
facility will pick the first one in the list).  For instance, (help con def)  
would be sufficient for the above example.

A few special fields can be used while in the help facility.

^      Branch up one level.
?      When specified at the end of a path, this forces a display of the  
       current menu, even on branch-ups.
<nil>  Giving no topic field will branch up one level.

A branch-up from the MAIN topic root node implies an exit from help.

By default, the help facility comes up in the MAIN topic root menu and the 
user may make a choice as described above.  The prompt line always displays 
the name of the current menu.  The help facility will branch through the help-
tree until instructed to exit by a branch-up from the top level.  The level 
always is reset to the MAIN topic upon exit from the help facility.

The first call to the help facility will take longer than successive calls  
while the system loads help information into an internal lookup table.  All 
other calls to the help facility are very fast.

The help facility reads help information from a file during execution.  Users  
may wish to change the location of the help file to meet the configuration of 
their system.  The help-path function was provided to allow this.

Syntax:
   (help-path [<help-file-name>])

If no argument is specified, the function displays the name of the current 
help file.  If an argument is specified, the help facility will use the new 
file name for future help references during this CLIPS session.  To change the 
location of the help file permanently, a change must be made in the setup.h 
file, then CLIPS must be recompiled.  The help-path function has no return 
value.

END-ENTRY

1MBEGIN-ENTRY-RELEASE_NOTES

RELEASE_NOTES

The release notes help section contains information about new features
and where to get technical support.

Subtopics:
NEW_FEATURES               SUPPORT_INFORMATION
FUZZY_NEW_FEATURES

END-ENTRY

2IBEGIN-ENTRY-FUZZY_NEW_FEATURES

RELEASE_NOTES
  FUZZY_NEW_FEATURES

FuzzyCLIPS is an extension to CLIPS that provides capabilities for handling 
fuzzy concepts and reasoning. It enables domain experts to express rules 
using their own fuzzy terms. It allows any mix of fuzzy and normal terms, 
numeric-comparison logic controls, and uncertainties in the rules and facts. 
Fuzzy sets and relations deal with fuzziness in approximate reasoning, while 
certainty factors for rules and facts manipulate the uncertainty.

Rules such as:

    (defrule hot-low  "shower temperature is hot and flow is low"
       (temp hot)
       (flow low)
     =>
       (cold-valve higher)
       (hot-valve  lower)
    )

where temp, flow, cold-valve and hot-valve are fuzzy variables and hot, low,
higher and lower are linguistic terms that define the shape of fuzzy sets
used to describe concepts in the domain being reasoned about.

END-ENTRY

2IBEGIN-ENTRY-NEW_FEATURES

RELEASE_NOTES
  NEW_FEATURES
  
Version 6.0 of CLIPS contains five major enhancements. First, instances of 
user-defined classes in COOL can be pattern-matched on the left-hand side of 
rules. Second, CLIPS now contains considerable support for knowledge based 
systems software engineering. Support is now provided for building modular 
systems and many of the features previously available in CRSV are now directly 
supported in CLIPS (such as constraint consistency among uses of the same 
variable). Third, deftemplates can now have more than one multifield slot. 
Fourth, it is now possible to nest other conditional elements within a not 
conditional element and two new conditional elements, exists and forall, are 
supported. Fifth, a Windows 3.1 CLIPS interface is now available for PC 
compatible computers. In addition, MS-DOS 286 and 386 versions of CLIPS are 
available which can use extended memory. For a detailed listing of differences 
between versions 5.1 and 6.0 of CLIPS, refer to appendix D of the Basic 
Programming Guide.

END-ENTRY

2IBEGIN-ENTRY-SUPPORT_INFORMATION

RELEASE_NOTES
  SUPPORT_INFORMATION
  
CLIPS is available through the Computer Software Management and Information 
Center (COSMIC), which is the distribution point for NASA software. Price 
discounts are available to U.S. academic institutions. Further information can 
be obtained from

      COSMIC
      The University of Georgia
      382 E. Broad St.
      Athens, GA  30602

      Phone: (706) 542-3265
      FAX: (706) 542-4807
      Internet: service@cossack.cosmic.uga.edu

If you have problems using or installing CLIPS, the Software Technology Branch 
(STB) Help Desk can be contacted at (713) 286-8919 from 9:00 a.m. to 4:00 p.m. 
(Central Standard Time). Leave your name and number and a support person will 
get back to you. The STB Help Desk can also be reached via electronic mail at 
<stbprod@fdr.jsc.nasa.gov> or by FAX at (713) 286-4479. 

An electronic bulletin board containing information regarding CLIPS and other 
STB products can be reached 24 hours a day at (713) 286-5375 or (713) 286-
7252. Communications information is 300, 1200, or 2400 baud, no parity, 8 data 
bits, and 1 stop bit.

An electronic conferencing facility is also available to CLIPS users. 
Subscribers to this facility may send questions, observations, answers, 
editorials, etc., in the form of electronic mail to the conference.  All 
subscribers will have a copy of these messages reflected back to them at their 
respective electronic mail addresses to process at their leisure. All that is 
required is that you have an electronic mail address that is accessible either 
directly on the Internet or via a gateway connected thereto (e.g., BITNET or 
NASAMAIL). To subscribe, simply send a single line message to 
listserv@cossack.cosmic.uga.edu saying SUBSCRIBE CLIPS-LIST (the hyphen is 
required).  The subject field is ignored but the address found in the 
'Reply:', 'Reply to:', or 'From:' field will be entered in the distribution 
list.  Upon subscription you will receive a mail message instructing you how 
to participate in the conference from that point forward.

Usenet users can also find information and post questions about CLIPS to the 
comp.ai.shells news group.

END-ENTRY

1MBEGIN-ENTRY-CONSTRUCT_SUMMARY

CONSTRUCT_SUMMARY

This section gives a general overview of the available CLIPS constructs.

Subtopics:
DEFRULE                    DEFCLASS
DEFFACTS                   DEFINSTANCES
DEFTEMPLATE                DEFMESSAGE-HANDLER
DEFGLOBAL                  DEFMODULE
DEFFUNCTION                CONSTRAINT_ATTRIBUTES            
DEFGENERIC/DEFMETHOD

END-ENTRY

2IBEGIN-ENTRY-DEFRULE

CONSTRUCT_SUMMARY
  DEFRULE

One of the primary methods of representing knowledge in CLIPS is a rule.  
A rule is a collection of conditions and the actions to be taken if the 
conditions are met.  The developer of an expert system defines the rules 
which describe how to solve a problem.  Rules execute (or fire) based on 
the existence or non-existence of facts.  CLIPS provides the mechanism 
(the inference engine) which attempts to match the rules to the current 
state of the system (as represented by the fact-list) and applies the 
actions.  

(defrule <rule-name> [<comment>]
    [<declaration>]              
    <conditional-element>*       
    =>
    <action>*)  

DECLARATIONS
------------------------------------------------------------------
<declaration>           ::= (declare <rule-property>+)

<rule-property>         ::= (salience <integer-expression>) |
                            (auto-focus <boolean-symbol>) |
                            (CF <numeric-expression>)

CONDITIONAL ELEMENTS
------------------------------------------------------------------
<conditional-element>   ::= <pattern-CE> | <assigned-pattern-CE> | 
                            <not-CE> | <and-CE> | <or-CE> |
                            <logical-CE> | <test-CE> |
                            <exists-CE> | <forall-CE>

<test-CE>               ::= (test <function-call>)

<not-CE>                ::= (not <conditional-element>) 

<and-CE>                ::= (and <conditional-element>+)
 
<or-CE>                 ::= (or <conditional-element>+)  
 
<exists-CE>             ::= (exists <conditional-element>+)

<forall-CE>             ::= (forall <conditional-element>
                                    <conditional-element>+)

<logical-CE>            ::= (logical <conditional-element>+)

PATTERN CONDITIONAL ELEMENT
------------------------------------------------------------------
<assigned-pattern-CE>   ::= ?<variable-symbol> <- <pattern-CE>

<pattern-CE>            ::= <ordered-pattern-CE> | 
                            <template-pattern-CE> |
                            <object-pattern-CE>

<ordered-pattern-CE>    ::= (<symbol> <constraint>*)

<template-pattern-CE>   ::= (<deftemplate-name> <LHS-slot>*) |
                            (<fuzzy-deftemplate-name> <fuzzy-linguistic-expr>)

<object-pattern-CE>     ::= (object <attribute-constraint>*)

<attribute-constraint>  ::= (is-a <constraint>) |
                            (name <constraint>) |
                            (<slot-name> <constraint>*)

<LHS-slot>              ::= <single-field-LHS-slot> | 
                            <multifield-LHS-slot> |
                            <fuzzy-LHS-slot>

<single-field-LHS-slot> ::= (<slot-name> <constraint>)

<multifield-LHS-slot>   ::= (<slot-name> <constraint>*)

<fuzzy-LHS-slot>        ::= (<slot-name> <fuzzy-linguistic-expr>)

<fuzzy-linguistic-expr> ::= <LTerm> | <fuzzy-linguistic-expr> OR <LTerm>
 
<LTerm>                 ::= <modExpr> | <LTerm> AND <modExpr>  

<modExpr>               ::= <fuzzy-modifier> <modExpr> | <element>
 
<element>               ::= <fuzzy-primary-term> | [ <fuzzy-linguistic-expr> ]
                            
<fuzzy-modifier>        ::= predefined or defined in add-fuzzy-modifier function

<fuzzy-primary-term>    ::= defined in a fuzzy deftemplate

PATTERN CONSTRAINTS
------------------------------------------------------------------
<constraint>            ::= ? | $? | <connected-constraint>

<connected-constraint>  
                ::= <single-constraint> |
                    <single-constraint> & <connected-constraint> |
                    <single-constraint> | <connected-constraint>

<single-constraint>     ::= <term> | ~<term>
                     
<term>                  ::= <constant> | 
                            <single-field-variable> |
                            <multifield-variable> |
                            :<function-call> |
                            =<function-call>
                            
END-ENTRY

2IBEGIN-ENTRY-DEFFACTS

CONSTRUCT_SUMMARY
  DEFFACTS
  
With the deffacts construct, a list of facts can be defined which are 
automatically asserted whenever the reset command is performed.  
Facts asserted through deffacts may be retracted or pattern matched like 
any other fact.  The initial fact-list, including any defined deffacts, 
is always reconstructed after a reset command.

The syntax of the deffacts construct is:

(deffacts <deffacts-name> [<comment>]
   <RHS-pattern>*)

END-ENTRY

2IBEGIN-ENTRY-DEFTEMPLATE

CONSTRUCT_SUMMARY
  DEFTEMPLATE
  
Ordered facts encode information positionally.  To access that information, 
a user must know not only what data is stored in a fact but which field 
contains the data.  Non-ordered (or deftemplate) facts provide the user 
with the ability to abstract the structure of a fact by assigning names 
to each field found within the fact.  The deftemplate construct is 
used to create a template which can then be used by non-ordered facts to 
access fields of the fact by name.  The deftemplate construct is analogous 
to a record or structure definition in programming languages such as Pascal 
and C.

The deftemplate construct is also used to define fuzzy template (variables)
which will be used in reasoning in a manner similar to standard CLIPS facts.
A fuzzy deftemplate identifies the fuzzy variable, its universe of discourse
(range of values and units), as well as the liguistic terms (e.g. hot, cold,
big, small) that will be used to describe fuzzy concepts.

The syntax of the deftemplate construct is:

(deftemplate <deftemplate-name> [<comment>]
   <slot-definition>*)

  - or -

(deftemplate <fuzzy-deftemplate-name> [<comment>]
   <universe-of-discourse>
   <fuzzy-term-list>)

<slot-definition>         ::= <single-slot-definition> | 
                              <multislot-definition>

<single-slot-definition>  ::= (slot <slot-name> 
                                    <template-attribute>*)

<multislot-definition>    ::= (multislot <slot-name> 
                                         <template-attribute>*)

<template-attribute>      ::= <default-attribute> |
                              <constraint-attribute>

<default-attribute>  
                   ::= (default ?DERIVE | ?NONE | <expression>*) |
                       (default-dynamic <expression>*)

<universe-of-discourse>    ::= <from-spec> <to-spec> [<units-spec>]

<from-spec>                ::= <numeric-expression>

<to-spec>                  ::= <numeric-expression>

<units-spec>               ::= <symbol>

<fuzzy-term-list>          ::= (<fuzzy-term> <fuzzy-term>*)

<fuzzy-term>               ::= (<name> <fuzzy-term-description>)

<fuzzy-term-description>   ::= <singleton-description> | <standard-description>

<singleton-description>    ::= <xy-pair> <xy-pair>*

<xy-pair>                  ::= (<numeric-expression> <numeric-expression>)


END-ENTRY

2IBEGIN-ENTRY-DEFGLOBAL

CONSTRUCT_SUMMARY
  DEFGLOBAL
  
With the defglobal construct, global variables can be defined, set, and 
accessed within the CLIPS environment.  Global variables can be accessed 
as part of the pattern matching process, but changing them does not invoke 
the pattern matching process.  The bind function is used to set the value 
of global variables.

The syntax of the defglobal construct is:

<defglobal-construct> ::= (defglobal [<defmodule-name>] 
                             <global-assignment>*)

<global-assignment>   ::= <global-variable> = <expression>

<global-variable>     ::= ?*<symbol>*


END-ENTRY

2IBEGIN-ENTRY-DEFFUNCTION

CONSTRUCT_SUMMARY
  DEFFUNCTION
  
With the deffunction construct, new functions may be defined directly in 
CLIPS.  Deffunctions are equivalent in use to other functions in CLIPS.  
The only differences between user-defined external functions and 
deffunctions are that deffunctions are written in CLIPS and executed 
by CLIPS interpretively and user-defined external functions are written 
in an external language, such as C, and executed by CLIPS directly.  
Also, deffunctions allow the addition of new functions without having to 
recompile and relink CLIPS.

The syntax of the deffunction construct is:

(deffunction <name> [<comment>]
    (<regular-parameter>* [<wildcard-parameter>])
    <action>*)

<regular-parameter>  ::= <single-field-variable>
<wildcard-parameter> ::= <multifield-variable>

END-ENTRY

2IBEGIN-ENTRY-DEFGENERIC/DEFMETHOD

CONSTRUCT_SUMMARY
  DEFGENERIC/DEFMETHOD
  
With the defgeneric/defmethod constructs, new generic functions may be written 
directly in CLIPS.  Generic functions are similar to deffunctions because 
they can be used to define new procedural code directly in CLIPS, and they can 
be called like any other function. However, generic functions are much more 
powerful because they can do different things depending on the types 
(or classes) and number of their arguments. For example, a '+' operator could 
be defined which performs concatenation for strings but still performs 
arithmetic addition for numbers.  Generic functions are comprised of 
multiple components called methods, where each method handles different 
cases of arguments for the generic function.  A generic function which has 
more than one method is said to be overloaded.

A generic function is comprised of a header (similar to a forward declaration) 
and zero or more methods.  A generic function header can either be explicitly 
declared by the user or implicitly declared by the definition of at least one 
method. The defgeneric construct is used to specify the generic function 
header,
and the defmethod construct is used for each of the generic function's 
methods.

The syntax of the defgeneric/defmethod constructs is:

(defgeneric <name> [<comment>])

(defmethod <name> [<index>] [<comment>]
    (<parameter-restriction>* [<wildcard-parameter>])
    <action>*)

<parameter-restriction> ::= <single-field-variable> |
                            (<single-field-variable> <type>* [<query>])

<wildcard-parameter>    ::= <multifield-variable>

<type>                  ::= <class-name>

<query>                 ::= <global-variable> | <function-call>
                            
END-ENTRY

2IBEGIN-ENTRY-DEFCLASS

CONSTRUCT_SUMMARY
  DEFCLASS

A defclass is a construct for specifying the properties (slots) of a class of 
objects.  A defclass consists of four elements: 1) a name, 2) a list of 
superclasses from which the new class inherits slots and message-handlers, 
3)  a specifier saying whether or not the creation of direct instances of the 
new class is allowed and 4) a list of slots specific to the new class.  All 
user-defined classes must inherit from at least one class, and to this end 
COOL provides predefined system classes for use as a base in the derivation 
of new classes.

Any slots explicitly given in the defclass override those gotten from 
inheritance.  COOL applies rules to the list of superclasses to generate a 
class precedence list for the new class.  Facets further describe slots.  
Some examples of facets include: default value, cardinality, and types of 
access allowed.

The syntax of the defclass construct is:

(defclass <name> [<comment>]
  (is-a <superclass-name>+)
  [<role>]
  [<pattern-match-role>]
  <slot>*
  <handler-documentation>*)

<role>  ::= (role concrete | abstract)

<pattern-match-role> 
        ::= (pattern-match reactive | non-reactive)

<slot>  ::= (slot <name> <facet>*) |
            (single-slot <name> <facet>*) |
            (multislot <name> <facet>*)

<facet> ::=  <default-facet> | <storage-facet> |
             <access-facet> | <propagation-facet> | 
             <source-facet> | <pattern-match-facet> |
             <visibility-facet> | <create-accessor-facet>
             <override-message-facet> | <constraint-attributes>
 
<default-facet> ::= 
           (default ?DERIVE | ?NONE | <expression>*) |
           (default-dynamic <expression>*)

<storage-facet> ::= (storage local | shared)

<access-facet> 
       ::= (access read-write | read-only | initialize-only)

<propagation-facet> ::= (propagation inherit | no-inherit)

<source-facet> ::= (source exclusive | composite)

<pattern-match-facet> 
       ::= (pattern-match reactive | non-reactive)

<visibility-facet> ::= (visibility private | public)

<create-accessor-facet> 
     ::= (create-accessor ?NONE | read | write | read-write)

<override-message-facet> 
     ::= (override-message ?DEFAULT | <message-name>)
                                           
<handler-documentation> 
       ::= (message-handler <name> [<handler-type>])

<handler-type> ::= primary | around | before | after

END-ENTRY

2IBEGIN-ENTRY-DEFINSTANCES

CONSTRUCT_SUMMARY
  DEFINSTANCES
  
Similar to deffacts, the definstances construct allows the specification of 
instances which will be created every time the reset command is executed.  
On every reset all current instances receive a delete message, and the 
equivalent of a make-instance function call is made for every instance 
specified in definstances constructs.

The syntax of the definstances construct is:

<definstances-construct> 
                ::= (definstances <definstances-name> [<comment>]
                       <instance-template>*)

<instance-template>   ::= (<instance-definition>)

<instance-definition> ::= <instance-name-expression> of
                             <class-name-expression>
                             <slot-override>*

<slot-override>       ::= (<slot-name-expression> <expression>*)

END-ENTRY

2IBEGIN-ENTRY-DEFMESSAGE-HANDLER

CONSTRUCT_SUMMARY
  DEFMESSAGE-HANDLER
  
Objects are manipulated by sending them messages via the function send.  The 
result of a message is a useful return-value or side-effect.  A 
defmessage-handler is a construct for specifying the behavior of a class of 
objects in response to a particular message.  The implementation of a message 
is made up of pieces of procedural code called message-handlers (or handlers 
for short).  Each class in the class precedence list of an object's class can 
have handlers for a message.  In this way, the object's class and all its 
superclasses share the labor of handling the message.  Each class's handlers 
handle the part of the message which is appropriate to that class.  Within a 
class, the handlers for a particular message can be further subdivided into 
four types or categories: primary, before, after and around.

A defmessage-handler is comprised of seven elements: 1) a class name to which 
to attach the handler (the class must have been previously defined), 2) a 
message name to which the handler will respond, 3) an optional type (the 
default is primary), 4) an optional comment, 5) a list of parameters that will
be passed to the handler during execution, 6) an optional wildcard parameter 
and 7) a series of expressions which are executed in order when the handler 
is called.  The return-value of a message-handler is the evaluation of the 
last 
expression in the body.

The syntax of the defmessage-handler construct is:
  
(defmessage-handler <class-name> <message-name>
   [<handler-type>] [<comment>]
   (<parameter>* [<wildcard-parameter>])
   <action>*)

<handler-type>       ::= around | before | primary | after

<parameter>          ::= <single-field-variable>

<wildcard-parameter> ::= <multifield-variable>

END-ENTRY

2IBEGIN-ENTRY-DEFMODULE

CONSTRUCT_SUMMARY
  DEFMODULE
  
CLIPS provides support for the modular development and execution of knowledge 
bases with the defmodule construct. CLIPS modules allow a set of constructs to 
be grouped together such that explicit control can be maintained over 
restricting the access of the constructs by other modules. This type of 
control is similar to global and local scoping used in languages such as C or 
Ada. By restricting access to deftemplate and defclass constructs, modules can 
function as blackboards, permitting only certain facts and instances to be 
seen by other modules. Modules are also used by rules to provide execution 
control.

The syntax of the defmodule construct is:

<defmodule-construct> ::= (defmodule <module-name> [<comment>] 
                             <port-spec>*)

<port-specification>  ::= (export <port-item>) |
                          (import <module-name> <port-item>)
                
<port-item>           ::= ?ALL |
                          ?NONE |
                          <port-construct> ?ALL |
                          <port-construct> ?NONE |
                          <port-construct> <construct-name>+ 

<port-construct>      ::= deftemplate | defclass |
                          defglobal | deffunction | defgeneric

END-ENTRY

2IBEGIN-ENTRY-CONSTRAINT_ATTRIBUTES

CONSTRUCT_SUMMARY
  CONSTRAINT_ATTRIBUTES
  
Constraint attributes can be associated with deftemplate and defclass slots so 
that type checking can be performed on slot values when template facts and 
instances are created. The constraint information is also analyzed for the 
patterns on the LHS of a rule to determine if the specified constraints 
prevent the rule from ever firing.

The syntax for constraint attributes is:
  
<constraint-attribute> ::= <type-attribute>J|
                           <allowed-constant-attribute> |
                           <range-attribute> |
                           <cardinality-attribute>
                           <default-attribute>

<type-attribute>       ::= (type <type-specification>)

<type-specification>   ::= <allowed-type>+ | ?VARIABLE

<allowed-type>         ::= SYMBOL | STRING | LEXEME |
                           INTEGER | FLOAT | NUMBER | 
                           INSTANCE-NAME | INSTANCE-ADDRESS |
                           INSTANCE |
                           EXTERNAL-ADDRESS | FACT-ADDRESS

<allowed-constant-attribute> 
                       ::= (allowed-symbolsJ<symbol-list>) |
                           (allowed-strings <string-list>) |
                           (allowed-lexemes <lexeme-list> |
                           (allowed-integersJ<integer-list>) |
                           (allowed-floatsJ<float-list>) |
                           (allowed-numbersJ<number-list>) |
                           (allowed-instance-names <instance-list>) |
                           (allowed-valuesJ<value-list>) |

<symbol-list>          ::= <symbol>+ | ?VARIABLE

<string-list>          ::= <string>+ | ?VARIABLE

<lexeme-list>          ::= <lexeme>+ | ?VARIABLE

<integer-list>         ::= <integer>+ | ?VARIABLE

<float-list>           ::= <float>+ | ?VARIABLE

<number-list>          ::= <number>+ | ?VARIABLE

<instance-name-list>   ::= <instance-name>+ | ?VARIABLE

<value-list>           ::= <constant>+ | ?VARIABLE

<range-attribute>      ::= (range <range-specification> 
                                  <range-specification>)

<range-specification>  ::= <number> | ?VARIABLE

<cardinality-attribute>    
                    ::= (cardinality <cardinality-specification> 
                                     <cardinality-specification>)

<cardinality-specification> ::= <integer> | ?VARIABLE

END-ENTRY

1MBEGIN-ENTRY-FUNCTION_SUMMARY

FUNCTION_SUMMARY

This section gives a general overview of the available CLIPS functions.

Subtopics: 
PREDICATE_FUNCTIONS        DEFRULE_FUNCTIONS
MULTIFIELD_FUNCTIONS       AGENDA_FUNCTIONS
STRING_FUNCTIONS           DEFGLOBAL_FUNCTIONS
IO_FUNCTIONS               DEFFUNCTION_FUNCTIONS
MATH_FUNCTIONS             GENERIC_FUNCTION_FUNCTIONS
PROCEDURAL_FUNCTIONS       COOL_FUNCTIONS
MISCELLANEOUS_FUNCTIONS    DEFMODULE_FUNCTIONS
DEFTEMPLATE_FUNCTIONS      SEQUENCE_EXPANSION_FUNCTIONS
FACT_FUNCTIONS             CERTAINTY_FACTOR_FUNCTIONS
FUZZY_FUNCTIONS

END-ENTRY

2IBEGIN-ENTRY-FUZZY_FUNCTIONS

The following functions allow access to the components of matched fuzzy facts
or fuzzy values. In all of the descriptions below <fv-var> represents one of 3
options that provides a link to a fuzzy value: a fact-address of a fuzzy
deftemplate fact, a fact id of a fuzzy deftemplate fact, or a fuzzy value.

GET-U: Returns a string of the form "<from> - <to> <units>".
(get-u <fv-var>)

GET-U-FROM: Returns the lower limit of the universe of discourse.
(get-u-from <fv-var>)

GET-U-TO: Returns the upper limit of the universe of discourse.
(get-u-to <fv-var>)

GET-U-UNITS: Returns the units of the universe of discourse as a string.
(get-u-units <fv-var>

GET-FS: Returns the fuzzy set for the fuzzy fact in string format.
(get-fs <fv-var>)

GET-FS-X: Returns the ith x value in the fuzzy set.
(get-fs-x <fv-var> <integer-expression>)

GET-FS-Y: Returns the ith y value in the fuzzy set.
(get-fs-y <fv-var> <integer-expression>)

GET-FS-LV: Returns the linguistic value of the fuzzy value (e.g. very cold).
(get-fs-lv <fv-var>)

GET-FS-VALUE: Returns the membership value at the specified x value.
(get-fs-value <fv-var> <x-value>)

CREATE-FUZZY-VALUE: creates a fuzzy value
(create-fuzzy-value <fuzzy-deftemplate-name> <fuzzy-value-expression>)

FUZZY-UNION: Returns a fuzzy value which is the union of the 2 fuzzy value 
             arguments.
(fuzzy-union <fuzzy-value> <fuzzy-value>)

FUZZY-INTERSECTION: Returns a fuzzy value which is the intersection of the 
                    2 fuzzy value arguments.
(fuzzy-intersection <fuzzy-value> <fuzzy-value>)

FUZZY-MODIFY: Returns a fuzzy value which is a modification of the fuzzy value
              given in the first argument by the modifier (hedge) specified in the
              2nd argument.

FUZZYVALUEP:  Predicate function that determines if its argument is a fuzzy value.
(fuzzyvaluep <arg>)

PLOT-FUZZY-VALUE: Plots the fuzzy value membership function.
(plot-fuzzy-value <logicalName> <plotChars> <lowLimit> <highLimit>
                  (fuzzy-value>*)

ADD-FUZZY-MODIFIER: Adds a user defined fuzzy modifier (hedge) to the list of
             fuzzy modifiers.
(add-fuzzy-modifier <modifierName> <modifierFunction>)

REMOVE-FUZZY-MODIFIER: Removes a user defined fuzzy modifier (hedge) from the list of
             fuzzy modifiers.
(remove-fuzzy-modifier <modifierName>)

SET-FUZZY-INFERENCE-TYPE: Sets the fuzzy inference type to one of max-min or max-prod.
(set-fuzzy-inference-type max-min | max-prod)

GET-FUZZY-INFERENCE-TYPE: Gets the current fuzzy inference (max-min or max-prod).
(set-fuzzy-inference-type)

SET-FUZZY-DISPLAY-PRECISION: Sets the number of digits of precision used when displaying
             fuzzy membership x, y values.
(set-fuzzy-display-precision <integer>)

GET-FUZZY-DISPLAY-PRECISION: Gets the number of digits of precision used when displaying
             fuzzy membership x, y values.
(get-fuzzy-display-precision)

SET-ALPHA-VALUE: Set the 'alpha' value which is a number between 0 and 1. It is used to
             set the threshold for matching fuzzy patterns against fuzzy facts.
(set-alpha-value <float-expression>)

GET-ALPHA-VALUE: Get the 'alpha' value which is a number between 0 and 1. It is used to
             set the threshold for matching fuzzy patterns against fuzzy facts.
(set-alpha-value)


END-ENTRY

2IBEGIN-ENTRY-CERTAINTY_FACTOR_FUNCTIONS

The following functions allow access to certainty factor information for
fuzzy facts and the current certainty threshold in the system.
In all of the descriptions below <fv-var> represents one of 3
options that provides a link to a fuzzy value: a fact-address of a fuzzy
deftemplate fact, a fact id of a fuzzy deftemplate fact, or a fuzzy value.

GET-CF: Returns the certainty factor for the fact.
(get-cf <fv-var>)

SET-THRESHOLD: Sets the threshold certainty factor for the system (from 0.0 to 1.0).
(threshold <numeric-expression>)

GET-THRESHOLD: Returns the current certainty factor threshold.
(get-threshold)

SET-CF-EVALUATION: Sets the behavious for evaluating the CF of rules.
(set-cf-evaluation when-defined | when-activated)

GET-CF-EVALUATION: Returns the current value of the behaviour for evaluation of
                   CF for rules.
(get-cf-evaluation)

END-ENTRY

2IBEGIN-ENTRY-PREDICATE_FUNCTIONS

FUNCTION_SUMMARY
  PREDICATE_FUNCTIONS
  
The following functions perform predicate tests and return
either TRUE or FALSE.

FUZZYVALUEP:  Returns TRUE for fuzzy values.
(fuzzyvaluep <arg>)

NUMBERP: Returns TRUE for integers and floats.
(numberp <expression>)

FLOATP: Returns TRUE for floats.
(floatp <expression>)

INTEGERP: Returns TRUE for integers.
(integerp <expression>)

LEXEMEP: Returns TRUE for symbols and strings.
(numberp <expression>)

STRINGP: Returns TRUE for strings.
(stringp <expression>)

SYMBOLP: Returns TRUE for symbols.
(symbolp <expression>)

EVENP: Returns TRUE for even numbers.
(evenp <expression>)

ODDP: Returns TRUE for odd numbers.
(oddp <expression>)

MULTIFIELDP: Returns TRUE for multifield values.
(multifieldp <expression>)

POINTERP: Returns TRUE for external addresses.
(pointerp <expression>)

EQ: Returns TRUE if the 1st argument is equal in type and value
    to all subsequent arguments.
(eq <expression> <expression>+)

NEQ: Returns TRUE if the 1st argument is not equal in type and
     value to all subsequent arguments.
(neq <expression> <expression>+)

=: Returns TRUE if the 1st argument is equal in value
   to all subsequent arguments.
(= <numeric-expression> <numeric-expression>+)

<>: Returns TRUE if the 1st argument is not equal in value
    to all subsequent arguments.
(<> <numeric-expression> <numeric-expression>+)

>: Returns TRUE if each argument is greater in value than the
   argument following it.
(> <numeric-expression> <numeric-expression>+)

>=: Returns TRUE if each argument is greater than or equal to 
    in value than the argument following it.
(>= <numeric-expression> <numeric-expression>+)

<: Returns TRUE if each argument is less in value than the
   argument following it.
(> <numeric-expression> <numeric-expression>+)

<=: Returns TRUE if each argument is less than or equal to 
    in value than the argument following it.
(<= <numeric-expression> <numeric-expression>+)
   
AND: Returns TRUE if all arguments evaluate to a non-FALSE value.
(and <expression>+)

OR: Returns TRUE if any argument evaluates to a non-FALSE value.
(or <expression>+)

NOT: Returns TRUE if its only argument evaluates to FALSE.
(not <expression>)
   
END-ENTRY

2IBEGIN-ENTRY-MULTIFIELD_FUNCTIONS

FUNCTION_SUMMARY
  MULTIFIELD_FUNCTIONS

The following functions operate on multifield values.

CREATE$: Appends its arguments together to create a multifield value.
(create$ <expression>*)

NTH$: Returns the specified field of a multifield value.
(nth$ <integer-expression> <multifield-expression>)

MEMBER$: Returns the position of a single-field value within a multifield 
value.
(member$ <single-field-expression> <multifield-expression>)

SUBSETP: Returns TRUE if the first argument is a subset of the second 
argument.
(subsetp <multifield-expression> <multifield-expression>)

DELETE$: Deletes the specified range from a multifield value.
(delete$ <multifield-expression>
         <begin-integer-expression> <end-integer-expression>)

EXPLODE$: Creates a multifield value from a string.
(explode$ <string-expression>)

IMPLODE$: Creates a string from a multifield value.
(implode$ <multifield-expression>)

SUBSEQ$: Extracts the specified range from a multifield value.
(subseq$ <multifield-expression> 
         <begin-integer-expression> <end-integer-expression>)

REPLACE$: Replaces the specified range of a multifield value with a 
          set of values.
(replace$ <multifield-expression>
          <begin-integer-expression> <end-integer-expression> 
          <single-or-multifield-expression>+)

INSERT$: Inserts one or more values in a multifield.
(insert$ <multifield-expression> <integer-expression> 
         <single-or-multifield-expression>+)

FIRST$: Returns the first field of a multifield.
(first$ <multifield-expression>)

REST$: Returns all but the first field of a multifield.
(rest$ <multifield-expression>)

LENGTH$: Returns the number of fields in a multifield value.
(length$ <multifield-expression>)

END-ENTRY

2IBEGIN-ENTRY-STRING_FUNCTIONS

FUNCTION_SUMMARY
  STRING_FUNCTIONS

The following functions perform operations that are related to strings.

STR-CAT: Concatenates its arguments to form a single string.
(str-cat <expression>*)

SYM-CAT: Concatenates its arguments to form a single symbol.
(sym-cat <expression>*)

SUB-STRING: Retrieves a subportion from a string.
(sub-string <integer-expression> <integer-expression> <string-expression>)

STR-INDEX: Returns the position of the first argument within the second 
           argument.
(str-index <lexeme-expression> <lexeme-expression>)

EVAL: Evaluates a string as though it were entered at the command prompt.
      Only allows functions to be evaluated.
(eval <lexeme-expression>)

BUILD: Evaluates a string as though it were entered at the command prompt.
       Only allows constructs to be evaluated.
(build <lexeme-expression>)

UPCASE: Converts lowercase characters in a string or symbol to uppercase.
(upcase <lexeme-expression>)

LOWCASE: Converts uppercase characters in a string or symbol to lowercase.
(lowcase <lexeme-expression>)

STR-COMPARE: Lexigraphically compares two strings.
(str-compare <lexeme-expression> <lexeme-expression>)

STR-LENGTH: Returns the length of a string.
(str-length <lexeme-expression>)

END-ENTRY

2IBEGIN-ENTRY-IO_FUNCTIONS

FUNCTION_SUMMARY
  IO_FUNCTIONS
  
The following functions perform I/O operations.

OPEN: Opens a file.
(open <file-name> <logical-name> [<mode>])
<mode> ::= "r" | "w" | "r+" | "a"

CLOSE: Closes a file.
(close [<logical-name>])

PRINTOUT: Sends unformated output to the specified logical name.
(printout <logical-name> <expresion>*)

READ: Reads a single-field value from the specified logical name.
(read [<logical-name>])

READLINE: Reads an entire line as a string from the specified 
          logical name.
(readline [<logical-name>])

FORMAT: Sends formated output to the specified logical name.
(format <logical-name> <string-expression> <expression>*)

RENAME: Changes the name of a file.
(rename <old-file-name> <new-file-name>)

REMOVE: Deletes a file.
(remove <file-name>)

END-ENTRY

2MBEGIN-ENTRY-MATH_FUNCTIONS

FUNCTION_SUMMARY
  MATH_FUNCTIONS

The math functions have been divided into three broad categories. The
basic math functions are always provided with CLIPS. The trigonometric
and extended math functions are included as part of the extended math
package.

Subtopics: 
BASIC_MATH_FUNCTIONS       EXTENDED_MATH_FUNCTIONS
TRIGONOMETRIC_FUNCTIONS    

END-ENTRY

3IBEGIN-ENTRY-BASIC_MATH_FUNCTIONS

FUNCTION_SUMMARY
  MATH_FUNCTIONS
    BASIC_MATH_FUNCTIONS
    
The following functions perform basic mathematical operations.

+: Returns the sum of its arguments.
(+ <numeric-expression> <numeric-expression>+)

-: Returns the first argument minus all subsequent arguments.
(- <numeric-expression> <numeric-expression>+)

*: Returns the product of its arguments.
(* <numeric-expression> <numeric-expression>+)

/: Returns the first argument divided by all subsequent arguments. 
(/ <numeric-expression> <numeric-expression>+)

DIV: Returns the first argument divided by all subsequent arguments
     using integer division. 
(div <numeric-expression> <numeric-expression>+)

MAX: Returns the value of its largest numeric argument.
(max <numeric-expression>+)

MIN: Returns the value of its smallest numeric argument.
(min <numeric-expression>+)

ABS: Returns the absolute value of its only argument.
(abs <numeric-expression>)

FLOAT: Converts its only argument to a float.
(float <numeric-expression>)

INTEGER: Converts its only argument to an integer.
(integer <numeric-expression>)

END-ENTRY

3IBEGIN-ENTRY-TRIGONOMETRIC_FUNCTIONS

FUNCTION_SUMMARY
  MATH_FUNCTIONS
    TRIGONOMETRIC_FUNCTIONS
    
The following trigonometric functions take one numeric argument  
and return a float.  The argument is expected to be in radians.
These functions are part of the extended math package.
    
FUNCTION         RETURNS
----------------------------------------
acos             arccosine
acosh            hyperbolic arccosine
acot             arccotangent
acoth            hyperbolic arccotangent
acsc             arccosecant
acsch            hyperbolic arccosecant
asec             arcsecant
asech            hyperbolic arcsecant
asin             arcsine
asinh            hyperbolic arcsine
atan             arctangent
atanh            hyperbolic arctangent
cos              cosine
cosh             hyperbolic cosine
cot              cotangent
coth             hyperbolic tangent
csc              cosecant
csch             hyperbolic cosecant
sec              secant
sech             hyperbolic secant
sin              sine
sinh             hyperbolic sine
tan              tangent
tanh             hyperbolic tangent

END-ENTRY

3IBEGIN-ENTRY-EXTENDED_MATH_FUNCTIONS

FUNCTION_SUMMARY
  MATH_FUNCTIONS
    EXTENDED_MATH_FUNCTIONS
    
The following functions perform extended mathematical operations
and are included as part of the extended math package.
    
DEG-GRAD: Converts its only argument from degrees to gradients.
(deg-grad <numeric-expression>)

DEG-RAD: Converts its only argument from degrees to radians.
(deg-rad <numeric-expression>)

GRAD-DEG: Converts its only argument from gradients to degrees.
(grad-deg <numeric-expression>)

RAD-DEG: Converts its only argument from radians to degrees.
(rad-deg <numeric-expression>)

PI: Returns the value of pi.
(pi)

SQRT: Returns the square root of its only argument.
(sqrt <numeric-expression>)

**: Raises its first argument to the power of its second argument.
(** <numeric-expression> <numeric-expression>)

EXP: Raises the value e to the power of its only argument.
(exp <numeric-expression>)

LOG: Returns the logarithm base e of its only argument.
(log <numeric-expression>)

LOG10: Returns the logarithm base 10 of its only argument.
(log10 <numeric-expression>)

ROUND: Rounds its argument toward the closest integer or negative
       infinity if exactly between two integers.
(round <numeric-expression>)

MOD: Returns the remainder of the result of dividing its first argument 
     by its second argument (assuming that the result of division must 
     be an integer).  
(mod <numeric-expression> <numeric-expression>)

END-ENTRY

2IBEGIN-ENTRY-PROCEDURAL_FUNCTIONS

FUNCTION_SUMMARY
  PROCEDURAL_FUNCTIONS

The following are functions which provide procedural programming
capabilities as found in languages such as Pascal, C, and Ada.

BIND: Binds a variable to a new value.
(bind <variable> <expression>*)

IF: Allows conditional execution of a group of actions.
(if <expression> then <action>* [else <action>*])

WHILE: Allows conditional looping.
(while <expression> [do] <action>*)

LOOP-FOR-COUNT: Allows simple iterative looping.
(loop-for-count <range-spec> [do] <action>*)
<range-spec>  ::= <end-index> |
                  (<loop-variable> [<start-index> <end-index>])
<start-index> ::= <integer-expression>
<end-index>   ::= <integer-expression>

PROGN: Evaluates all arguments and returns the value of the last 
       argument evaluated.
(progn <expression>*)

PROGN$: Performs a set of actions for each field of a multifield value.
(progn$ <list-spec> <expression>*)
<list-spec> ::= <multifield-expression> |
                (<list-variable> <multifield-expression>)

RETURN: Immediately terminates the currently executing deffunction,
        generic function method, message-handler, defrule RHS, or
        certain instance set query functions and if a value is 
        specified, returns this value as the result of the executing 
        construct.
(return [<expression>])

BREAK: Immediately terminates the currently iterating while loop,
       progn execution, or certain instance set query functions.
(break)

SWITCH: Allows a particular group of actions to be performed based
        on a specified value.
(switch <test-expression>
   <case-statement>
   <case-statement>+
   [<default-statement>])
<case-statement> ::= (case <comparison-expression> then <action>*)
<default-statement> ::= (default <action>*)

END-ENTRY

2IBEGIN-ENTRY-MISCELLANEOUS_FUNCTIONS

FUNCTION_SUMMARY
  MISCELLANEOUS_FUNCTIONS
    
The following are additional functions for use within CLIPS.

GENSYM: Returns a special sequenced symbol.
(gensym)

GENSYM*: Returns a special unique sequenced symbol.
(gensym*)

SETGEN: Sets the starting number used by gensym and gensym*.
(setgen <integer-expression>)

RANDOM: Returns a "random" integer value.
(random)

SEED: Seeds the random number generator used by random.
(seed <integer-expression>)

TIME: Returns a float representing the elapsed seconds since 
      the system reference time.
(time)

LENGTH: Returns an integer for the number of fields in a multifield value
        or the length in characters of a string or symbol.
(length <lexeme-or-multifield-expression>)

GET-FUNCTION_RESTRICTIONS: Returns the restriction string associated with 
                           a CLIPS or user defined function.
(get-function-restrictions <function-name>)


END-ENTRY

2IBEGIN-ENTRY-DEFTEMPLATE_FUNCTIONS

The following functions provide ancillary capabilities for the deftemplate 
construct.

GET-DEFTEMPLATE-LIST: Returns the list of all deftemplates in the specified
                      module (or the current module if unspecified).
(get-deftemplate-list [<module-name>])

DEFTEMPLATE-MODULE: Returns the module in which the specified deftemplate is
                    defined.
(deftemplate-module <deftemplate-name>)

END-ENTRY

2IBEGIN-ENTRY-FACT_FUNCTIONS

The following actions are used for assert, retracting, and modifying facts.

ASSERT: Adds a fact to the fact-list.
(assert <RHS-pattern>+)

RETRACT: Removes a fact from the fact-list.
(retract <retract-specifier>+ | *)
<retract-specifier> ::= <fact-specifier> | <integer-expression>

MODIFY: Modifies a deftemplate fact in the fact-list.
(modify <fact-specifier> <RHS-slot>*)

DUPLICATE: Duplicates a deftemplate fact in the fact-list.
(duplicate <fact-specifier> <RHS-slot>*)

ASSERT-STRING: Converts a string into a fact and asserts it.
(assert-string <string-expression>)

FACT-INDEX: Returns the fact index of a fact address.
(fact-index <fact-address>)

END-ENTRY

2IBEGIN-ENTRY-DEFFACTS_FUNCTIONS

The following functions provide ancillary capabilities for the deffacts 
construct.

GET-DEFFACTS-LIST: Returns the list of all deffacts in the specified
                   module (or the current module if unspecified).
(get-deffacts-list [<module-name>])

DEFFACTS-MODULE: Returns the module in which the specified deffacts is
                 defined.
(deffacts-module <deffacts-name>)

END-ENTRY

2IBEGIN-ENTRY-DEFRULE_FUNCTIONS

The following functions provide ancillary capabilities for the defrule 
construct.

GET-DEFRULE-LIST: Returns the list of all defrules in the specified
                  module (or the current module if unspecified).
(get-defrule-list [<module-name>])

DEFRULE-MODULE: Returns the module in which the specified defrule is
                defined.
(defrule-module <defrule-name>)

END-ENTRY

2IBEGIN-ENTRY-AGENDA_FUNCTIONS

The following functions provide ancillary capabilities for manipulating the 
agenda.

GET-FOCUS: Returns the module name of the current focus.
(get-focus)

GET-FOCUS-STACK: Returns all of the module names in the focus stack as a
                 multifield value.
(get-focus-stack)

POP-FOCUS: Removes the current focus from the focus stack and returns the
           module name of the current focus.
(pop-focus)

END-ENTRY

2IBEGIN-ENTRY-DEFGLOBAL_FUNCTIONS

The following functions provide ancillary capabilities for the defglobal 
construct.

GET-DEFGLOBAL-LIST: Returns the list of all defglobals in the specified
                    module (or the current module if unspecified).
(get-defglobal-list [<module-name>])

DEFGLOBAL-MODULE: Returns the module in which the specified defglobal is
                  defined.
(defglobal-module <defglobal-name>)

END-ENTRY

2IBEGIN-ENTRY-DEFFUNCTION_FUNCTIONS

The following functions provide ancillary capabilities for the deffunction 
construct.

GET-DEFFUNCTION-LIST: Returns the list of all deffunctions in the specified
                      module (or the current module if unspecified).
(get-deffunction-list [<module-name>])

DEFFUNCTION-MODULE: Returns the module in which the specified deffunction 
                    is defined.
(deffunction-module <deffunction-name>)

END-ENTRY

2IBEGIN-ENTRY-GENERIC_FUNCTION_FUNCTIONS 

FUNCTION_SUMMARY
  GENERIC_FUNCTION_FUNCTIONS
    
The following functions provide ancillary capabilities for generic 
function methods.

GET-DEFGENERIC-LIST: Returns the list of all defgenerics in the specified
                     module (or the current module if unspecified).
(get-defgeneric-list [<module-name>])

DEFGENERIC-MODULE: Returns the module in which the specified defgeneric 
                   is defined.
(defgeneric-module <defgeneric-name>)

GET-DEFMETHOD-LIST: Returns the list of all defmethods in the current
                    module (or just the methods associated with the
                    specified defgeneric).
(get-defmethod-list [<defgeneric-name>])

TYPE: Returns a symbol which is the name of the type (or class) 
       of its of argument.
(type <expression>)

NEXT-METHODP: If called from a method for a generic function, the function 
              next-methodp will return the symbol TRUE if there is another 
              method shadowed by the current one. Otherwise, the function
              will return the symbol FALSE.
(next-methodp)

CALL-NEXT-METHOD: Calls the next shadowed method.
(call-next-method)

OVERRIDE-NEXT-METHOD: Calls the next shadowed method allowing new 
                      arguments to be provided.
(override-next-method <expression>*)

CALL-SPECIFIC-METHOD: Calls a particular method of a generic function without
                      regards to method precedence.
(call-specific-method <generic-function> <method-index> <expression>*)

GET-METHOD-RESTRICTIONS: Returns a multifield value containing information
                         about the restrictions for the specified method.
(get-method-restrictions <generic-function-name> <method-index>)

END-ENTRY

2MBEGIN-ENTRY-COOL_FUNCTIONS

FUNCTION_SUMMARY
  COOL_FUNCTIONS

The functions manipulating the CLIPS Object-Oriented Language (COOL)
are divided into five categories. 

Subtopics: 
CLASS_FUNCTIONS                    INSTANCE_SLOT_FUNCTIONS
INSTANCE_MANIPULATION_FUNCTIONS    MESSAGE-HANDLER_FUNCTIONS  
DEFINSTANCES_FUNCTIONS             INSTANCE_PREDICATE_FUNCTIONS

END-ENTRY

3IBEGIN-ENTRY-CLASS_FUNCTIONS

FUNCTION_SUMMARY
  COOL_FUNCTIONS
    CLASS_FUNCTIONS

The following functions are used with classes. 

GET-DEFCLASS-LIST: Returns the list of all defclasses in the specified
                   module (or the current module if unspecified).
(get-defclass-list [<module-name>])

DEFCLASS-MODULE: Returns the module in which the specified defclass 
                   is defined.
(defclass-module <defclass-name>)

CLASS-EXISTP: Returns TRUE if the specified class is defined, FALSE otherwise.
(class-existp <class-name>)

SUPERCLASSP: Returns TRUE if the first class is a superclass of
             the second class, FALSE otherwise.
(superclassp <class1-name> <class2-name>)

SUBCLASSP: Returns TRUE if the first class is a subclass of
           the second class, FALSE otherwise.
(subclassp <class1-name> <class2-name>)

SLOT-EXISTP: Returns TRUE if the specified slot is present in the class, 
             FALSE otherwise. If the inherit keyword is specified, then
             the slot may be inherited.
(slot-existp <class-name> <slot-name> [inherit])

SLOT-WRITABLEP: Returns TRUE if the specified slot is writable, 
                otherwise FALSE.
(slot-writablep <class-name> <slot-name>)

SLOT-INITABLEP: Returns TRUE if the specified slot is initializable, 
                otherwise FALSE.
(slot-initablep <class-name> <slot-name>)

SLOT-PUBLICP: Returns TRUE if the specified slot is public, 
              otherwise FALSE.
(slot-initablep <class-name> <slot-name>)

SLOT-DIRECT-ACCESSP: Returns TRUE if the specified slot can be accessed 
                     directly, otherwise FALSE.
(slot-direct-accessp <class-name> <slot-name>)

MESSAGE-HANDLER-EXISTP: Returns TRUE if the specified message-handler is 
                        defined (directly, not by inheritance) for the 
                        class, FALSE otherwise.
(message-handler-existp <class-name> <handler-name> [<handler-type>])
<handler-type> ::= around | before | primary | after

CLASS-ABSTRACTP: Returns TRUE if the specified class is abstract,
                 FALSE otherwise.
(class-abstractp <class-name>)

CLASS-REACTIVEP: Returns TRUE if the specified class is reactive,
                 FALSE otherwise.
(class-reactivep <class-name>)

CLASS-SUPERCLASSES: Returns the names of the direct superclasses of a class in
                    a multifield variable. If the optional "inherit" argument 
                    is given, indirect superclasses are also included.
(class-superclasses <class-name> [inherit])

CLASS-SUBCLASSES: Returns the names of the direct subclasses of a class in a
                  multifield variable. If the optional "inherit" argument is
                  given, indirect subclasses are also included.
(class-subclasses <class-name> [inherit])

CLASS-SLOTS: Returns the names of the explicitly defined slots of a class in
             a multifield variable. If the optional inherit keyword is
             given, inherited slots are also included.
(class-slots <class-name> [inherit])

GET-DEFMESSAGE-HANDLER-LIST: Returns the class names, message names, and 
                             message types of the message-handlers directly 
                             attached to a class in a multifield variable. If 
                             the optional inherit keyword is given, inherited 
                             message-handlers are also included.
(get-defmessage-handler-list <class-name> [inherit])

SLOT-FACETS: Returns the facet values for the specified slot of a class in a
             multifield value.
(slot-facets <class-name> <slot-name>)

SLOT-SOURCES: Returns the names of the classes which provide facets for a 
              slot of a class in a multifield variable.
(slot-sources <class-name> <slot-name>)

SLOT-TYPES: Returns the names of the primitive types allowed for a slot
            in a multifield variable.
(slot-types <class-name> <slot-name>)

SLOT-CARDINALITY: Returns the minimum and maximum number of fields allowed 
                  for a multislot in a multifield variable.
(slot-cardinality <class-name> <slot-name>)

SLOT-ALLOWED-VALUES: Returns the allowed values for a slot in a  
                     multifield value.
(slot-allowed-values <class-name> <slot-name>)

SLOT-RANGE: Returns the minimum and maximum numeric values allowed
            for a slot.
(slot-range <class-name> <slot-name>)

END-ENTRY

3IBEGIN-ENTRY-MESSAGE-HANDLER_FUNCTIONS

FUNCTION_SUMMARY
  COOL_FUNCTIONS
    MESSAGE-HANDLER_FUNCTIONS

The following functions are used with message-handlers. 

NEXT-HANDLERP: Returns TRUE if there is another message-handler available
               for execution, FALSE otherwise.
(next-handlerp)

CALL-NEXT-HANDLER: Calls the next shadowed handler.
(call-next-handler)

OVERRIDE-NEXT-HANDLER: Calls the next shadowed handler and allows the 
                       arguments to be changed.
(override-next-handler <expression>*)

END-ENTRY

3IBEGIN-ENTRY-DEFINSTANCES_FUNCTIONS

FUNCTION_SUMMARY
  COOL_FUNCTIONS
    DEFINSTANCES_FUNCTIONS

The following functions are used with definstances. 

GET-DEFINSTANCES-LIST: Returns the list of all definstances in the specified
                       module (or the current module if unspecified).
(get-definstances-list [<module-name>])

DEFINSTANCES-MODULE: Returns the module in which the specified definstance 
                     is defined.
(definstances-module <definstances-name>)

END-ENTRY

3IBEGIN-ENTRY-INSTANCE_MANIPULATION_FUNCTIONS

FUNCTION_SUMMARY
  COOL_FUNCTIONS
    INSTANCE_MANIPULATION_FUNCTIONS

The following manipulation functions are used with instances. 

INIT-SLOTS: Implements the init message-handler attached to the class
            USER. This function should never be called directly unless
            an init message-handler is being defined such that the one
            attached to USER will never be called.
(init-slots)

UNMAKE-INSTANCE: Deletes the specified instance by sending it 
                 the delete message.
(unmake-instance <instance-expression> | *)

DELETE-INSTANCE: Deletes the active instance when called from within
                 the body of a message-handler.
(delete-instance)

CLASS: Returns a symbol which is the name of the class of its argument.
(class <object-expression>)

INSTANCE-NAME: Returns a symbol which is the name of its instance argument.
(instance-name <instance-expression>)

INSTANCE-ADDRESS: Returns the address of its instance argument.
(instance-address <instance-expression>)

SYMBOL-TO-INSTANCE-NAME: Converts a symbol to an instance name.
(symbol-to-instance-name <symbol-expression>)

INSTANCE-NAME-TO-SYMBOL: Converts an instance name to a symbol.
(instance-name-to-symbol <instance-name-expression>)

END-ENTRY

3IBEGIN-ENTRY-INSTANCE_PREDICATE_FUNCTIONS

FUNCTION_SUMMARY
  COOL_FUNCTIONS
    INSTANCE_PREDICATE_FUNCTIONS

The following predicate functions are used with instances. 

INSTANCEP: Returns TRUE if its argument is an instance name or instance
           address, FALSE otherwise.
(instancep <expression>)

INSTANCE-ADDRESSP: Returns TRUE if its argument is an instance address,
                   FALSE otherwise.
(instance-addressp <expression>)

INSTANCE-NAMEP: Returns TRUE if its argument is an instance name,
                FALSE otherwise.
(instance-namep <expression>)

INSTANCE-EXISTP: Returns TRUE if the specified instance exists,
                 FALSE otherwise.
(instance-existp <instance-expression>)

END-ENTRY

3IBEGIN-ENTRY-INSTANCE_SLOT_FUNCTIONS

FUNCTION_SUMMARY
  COOL_FUNCTIONS
    INSTANCE_SLOT_FUNCTIONS

The following functions are used to manipulate instance slots. 

DYNAMIC-GET: Returns the value of the specified slot of the active instance.
(dynamic-get <slot-name-expression>)

DYNAMIC-PUT: Sets the value of the specified slot of the active instance.
(put <slot-name-expression> <expression>*)

SLOT-REPLACE$: Allows the replacement of a range of fields in a multifield
               slot value.
(slot-replaceR <instance-expression> <mv-slot-name>
               <range-begin> <range-end> <expression>+)
                 
DIRECT-SLOT-REPLACE$: Allows the replacement of a range of fields in a
                      multifield slot value of the active instance from 
                      within a message-handler.
(direct-slot-replace$ <mv-slot-name> <range-begin> <range-end> <expression>+)
   
SLOT-INSERT$: Allows the insertion of one or more values in a multifield
              slot value.
(slot-insert$ <instance-expression> <mv-slot-name> <index> <expression>+)
                 
DIRECT-SLOT-INSERT$: Allows the insertion of one or more values in a
                     multifield slot value of the active instance from 
                     within a message-handler.
(direct-slot-insert$ <mv-slot-name> <index> <expression>+)
    
SLOT-DELETE$: Allows the deletion of a range of fields in a multifield
             slot value.
(slot-delete$ <instance-expression> <mv-slot-name> <range-begin> <range-end>)
                 
DIRECT-SLOT-DELETE$: Allows the deletion of a range of fields in a multifield
                     slot value of the active instance from within a 
                     message-handler.
(direct-slot-delete$ <mv-slot-name> <range-begin> <range-end>)
             
END-ENTRY

2IBEGIN-ENTRY-DEFMODULE_FUNCTIONS

The following functions provide ancillary capabilities for the defmodule 
construct.

GET-DEFMODULE-LIST: Returns the list of all defmodules.
(get-defmodule-list)

END-ENTRY

2IBEGIN-ENTRY-SEQUENCE_EXPANSION_FUNCTIONS

The following functions provide ancillary capabilities for the sequence 
expansion operator.

EXPAND$: When used inside of a function call, expands its arguments
         as separate arguements to the function. The $ operator is 
         merely a shorthand notation for the expand$ function call.
(expand$; <multifield-expression>)

SET-SEQUENCE-OPERATOR-RECOGNITION: Sets the sequence operator recognition
                                   behavior.
(set-sequence-operator-recognition; <boolean-expression>)

GET-SEQUENCE-OPERATOR-RECOGNITION: Returns the current value of the sequence 
                                   operator recognition behavior.
(get-sequence-operator-recognition)

END-ENTRY

1MBEGIN-ENTRY-COMMAND_SUMMARY

COMMAND_SUMMARY

This section gives a general overview of the available CLIPS commands.

Subtopics: 
ENVIRONMENT_COMMANDS       DEFGLOBAL_COMMANDS
DEBUGGING_COMMANDS         DEFFUNCTION_COMMANDS
DEFTEMPLATE_COMMANDS       GENERIC_FUNCTION_COMMANDS
FACT_COMMANDS              COOL_COMMANDS
DEFFACTS_COMMANDS          DEFMODULE_COMMANDS
DEFRULE_COMMANDS           MEMORY_COMMANDS
AGENDA_COMMANDS            TEXT_PROCESSING_COMMANDS
    
END-ENTRY

2IBEGIN-ENTRY-ENVIRONMENT_COMMANDS

COMMAND_SUMMARY
  ENVIRONMENT_COMMANDS
    
The following commands control the CLIPS environment.

LOAD: Loads constructs from a file.
(load <file-name>)

SAVE: Saves constructs to a file.
(save <file-name>)

BLOAD: Loads a binary image from a file.
(bload <file-name>)

BSAVE: Saves a binary image to a file.
(bsave <file-name>)

CLEAR: Clears the CLIPS environment.
(clear)

EXIT: Exits the CLIPS environment.
(exit)

RESET: Resets the CLIPS environment.
(reset)

BATCH: Executes commands from a file.
(batch <file-name>)

OPTIONS: Lists the settings of CLIPS compiler flags.
(options)

SYSTEM: Appends its arguments together to form a command which is
        then sent to the operating system.
(system <lexeme-expression>*)

SET-AUTO-FLOAT-DIVIDEND: Sets the auto-float dividend behaviour.
(set-auto-float-dividend <boolean-expression>)

GET-AUTO-FLOAT-DIVIDEND: Returns the current value of the auto-float 
                         dividend behaviour.
(get-auto-float-dividend)

SET-DYNAMIC-CONSTRAINT-CHECKING: Sets the dynamic constraint checking
                                 behaviour.
(set-dynamic-constraint-checking <boolean-expression>)

GET-DYNAMIC-CONSTRAINT-CHECKING: Returns the current value of the dynamic
                                 constraint checking behaviour.
(get-dynamic-constraint-checking)

SET-STATIC-CONSTRAINT-CHECKING: Sets the static constraint checking
                                behaviour.
(set-static-constraint-checking <boolean-expression>)

GET-STATIC-CONSTRAINT-CHECKING: Returns the current value of the static
                                constraint checking behaviour.
(get-static-constraint-checking)

APROPOS: Displays all symbols currently defined in CLIPS which contain 
         a specified substring
(apropos <lexeme>)

END-ENTRY

2IBEGIN-ENTRY-DEBUGGING_COMMANDS

COMMAND_SUMMARY
  DEBUGGING_COMMANDS
  
The following commands control the CLIPS debugging features.

DRIBBLE-ON: Sends trace information to the specified file.
(dribble-on <file-name>)

DRIBBLE-OFF: Closes the trace file.
(dribble-off)

WATCH: Enables trace information for the specified item.
(watch <watch-item>)
<watch-item> ::= all |
                 compilations | 
                 statistics |
                 focus |
                 messages |
                 deffunctions <deffunction-name>* |
                 globals <global-name>* |
                 rules <rule-name>* |
                 activations <rule-name>* |
                 facts <deftemplate-name>* |
                 instances <class-name>* |
                 slots <class-name>* |
                 message-handlers <handler-spec-1>* [<handler-spec-2>]) |
                 generic-functions <generic-name>* |
                 methods <method-spec-1>* [<method-spec-2>]

<handler-spec-1> ::= <class-name> <handler-name> <handler-type>
<handler-spec-2> ::= <class-name> [<handler-name> [<handler-type>]]

<method-spec-1> ::= <generic-name> <method-index>
<method-spec-2> ::= <generic-name> [<method-index>]

UNWATCH: Disables trace information for the specified item.
(unwatch <watch-item>)

LIST-WATCH-ITEMS: Displays the current state of watch items.
(list-watch-items [<watch-item>])

END-ENTRY

2IBEGIN-ENTRY-DEFTEMPLATE_COMMANDS

COMMAND_SUMMARY
  DEFTEMPLATE_COMMANDS

The following commands manipulate deftemplates.

PPDEFTEMPLATE: Displays the text of a given deftemplate.
(ppdeftemplate <deftemplate-name>)

LIST-DEFTEMPLATES: Displays the list of all deftemplates in the specified
                   module (or the current module if none specified).
(list-deftemplates [<module-name>])

UNDEFTEMPLATE: Deletes a deftemplate.
(undeftemplate <deftemplate-name>)

END-ENTRY

2IBEGIN-ENTRY-FACT_COMMANDS

COMMAND_SUMMARY
  FACT_COMMANDS

The following commands display information about facts.

FACTS: Display the facts in the fact-list.
(facts [<module-name>]
       [<start-integer-expression> 
       [<end-integer-expression> 
       [<max-integer-expression>]]])

LOAD-FACTS: Asserts facts loaded from a file.
(load-facts <file-name>)

SAVE-FACTS: Saves facts to a file.
(save-facts <file-name> [<save-scope> <deftemplate-names>*])
<save-scope> ::= visible | local

DEPENDENCIES: Lists the partial matches from which a fact or 
              instance receives logical support.
(dependencies <fact-or-instance-specifier>)

DEPENDENTS: Lists all facts or instances which receive logical support 
           from a fact or instance.
(dependents <fact-or-instance-specifier>)

SET-FACT-DUPLICATION: Sets the fact duplication behavior.
(set-fact-duplication <boolean-expression>)

GET-FACT-DUPLICATION: Returns the fact duplication behavior.
(get-fact-duplication)

END-ENTRY

2IBEGIN-ENTRY-DEFFACTS_COMMANDS

COMMAND_SUMMARY
  DEFFACTS_COMMANDS

The following commands manipulate deffacts.

PPDEFFACTS: Displays the text of a given deffacts.
(ppdeffacts <deffacts-name>)

LIST-DEFFACTS: Displays the list of all deffacts in the specified
               module (or the current module if none specified).
(list-deffacts [<module-name>])

UNDEFFACTS: Deletes a deffacts.
(undeffacts <deffacts-name>)

END-ENTRY

2IBEGIN-ENTRY-DEFRULE_COMMANDS

COMMAND_SUMMARY
  DEFRULE_COMMANDS

The following commands manipulate defrules.

PPDEFRULE: Displays the text of a given rule.
(ppdefrule <rule-name>)

LIST-DEFRULES: Displays the list of all defrules in the specified
               module (or the current module if none specified).
(list-defrules [<module-name>])

UNDEFRULE: Deletes a defrule.
(undefrule <rule-name>)

MATCHES: Displays the facts which match the patterns of a rule.
(matches <rule-name>)

SET-BREAK: Sets a breakpoint on a rule.
(set-break <rule-name>)

REMOVE-BREAK: Removes a breakpoint on a rule.
(remove-break [<rule-name>])

SHOW-BREAKS: Displays all rules having breakpoints.
(show-breaks [<module-name>])

REFRESH: Places all current activations of a rule on the agenda.
(refresh <rule-name>)

SET-INCREMENTAL-RESET: Sets the incremental reset behavior.
(set-incremental-reset <boolean-expression>)

GET-INCREMENTAL-RESET: Returns the incremental reset behavior.
(get-incremental-reset)

END-ENTRY

2IBEGIN-ENTRY-AGENDA_COMMANDS

COMMAND_SUMMARY
  AGENDA_COMMANDS

The following commands manipulate the agenda.

AGENDA: Displays all activations on the agenda of the specified module.
(agenda [<module-name>])

RUN: Starts execution of rules.  Rules fire until agenda is empty or
     the number of rule firings limit specified by the first argument 
     is reached (infinity if unspecified).
     A fuzzyCLIPS extension assigns a special meaning to the rule limit
     value -2 and values less than -2. For -2 the inference cycle will 
     continue forever (or until a break, control-C, is encountered).
     Even when the agenda is empty the cycle will continue and any
     functions added to the runtime list will be executed. If the 
     value is less than -2 then the cycle will continue until |limit|
     rules have been fired even if the agenda becomes empty at some time.
(run [<integer-expression>])

FOCUS: Pushes one or more modules onto the focus stack.
(focus <module-name>+)

HALT: Stops rule execution.
(halt)

SET-STRATEGY: Sets the current conflict resolution strategy.
(set-strategy <strategy>)
<strategy> ::= depth | breadth | simplicity | complexity | lex | mea | random

GET-STRATEGY: Returns the current conflict resolution strategy.
(get-strategy)

LIST-FOCUS-STACK: Lists all module names on the focus stack.
(list-focus-stack)

CLEAR-FOCUS-STACK: Removes all modules from the focus stack.
(clear-focus-stack)

SET-SALIENCE-EVALUATION: Sets the salience evaluation behavior.
(set-salience-evaluation <behavior>)
<behavior> ::= when-defined | when-activated | every-cycle

GET-SALIENCE-EVALUATION: Returns the salience evaluation behavior.
(get-salience-evaluation)

REFRESH-AGENDA: Forces reevaluation of salience of rules on the agenda
                of the specified module.
(refresh-agenda [<module-name>])

END-ENTRY

2IBEGIN-ENTRY-DEFGLOBAL_COMMANDS
COMMAND_SUMMARY
  DEFGLOBAL_COMMANDS
  
The following commands manipulate defglobals.

PPDEFGLOBAL: Displays the text required to define a given global variable.
(ppdefglobal <global-variable-name>)

LIST-DEFGLOBALS: Displays the list of all defglobals in the specified
                 module (or the current module if none specified).
(list-defglobals [<module-name>])

UNDEFGLOBAL: Deletes a global variable.
(undefglobal <global-variable-name>)

SHOWS-DEFGLOBALS: Displays the name and current value of all defglobals 
                  in the specified module (or the current module if none
                  specified).
(show-defglobals [<module-name>])

SET-RESET-GLOBALS: Sets the reset global variables behavior.
(set-reset-globals <boolean-expression>)

GET-RESET-GLOBALS: Returns the reset global variables behavior.
(get-reset-globals)

END-ENTRY

2IBEGIN-ENTRY-DEFFUNCTION_COMMANDS

COMMAND_SUMMARY
  DEFFUNCTION_COMMANDS
 
The following commands manipulate deffunctions.

PPDEFFUNCTION: Displays the text of a given deffunction.
(ppdeffunction <deffunction-name>)

LIST-DEFFUNCTIONS: Displays the list of all deffunctions in the specified
                   module (or the current module if none specified).
(list-deffunctions [<deffunction-name>])

UNDEFFUNCTION: Deletes a deffunction.
(undeffunction <deffunction-name>)

END-ENTRY

2IBEGIN-ENTRY-GENERIC_FUNCTION_COMMANDS

COMMAND_SUMMARY
  GENERIC_FUNCTION_COMMANDS
 
The following commands manipulate generic functions.

PPDEFGENERIC: Displays the text of a given generic function header.
(ppdefgeneric <generic-function-name>)

PPDEFMETHOD: Displays the text of a given method.
(ppdefmethod <generic-function-name> <index>)

LIST-DEFGENERICS: Displays the names of all generic functions in the specified
                  module (or the current module if none specified).
(list-defgenerics [<module-name>])

LIST-DEFMETHODS: Displays a list of generic function methods.
(list-defmethods [<generic-function-name>])

UNDEFGENERIC: Deletes a generic function.
(undefgeneric <generic-function-name>)

UNDEFMETHOD: Deletes a generic function method.
(undefmethod <generic-function-name> <index>)

PREVIEW-GENERIC: Lists all applicable methods for a particular generic
                 function call in order of decreasing precedence.
(preview-generic <generic-function-name> <expression>*)

END-ENTRY

2MBEGIN-ENTRY-COOL_COMMANDS

COMMAND_SUMMARY
  COOL_COMMANDS

The commands manipulating the CLIPS Object-Oriented Language (COOL)
are divided into four categories. 

Subtopics: 
CLASS_COMMANDS                MESSAGE-HANDLER_COMMANDS 
DEFINSTANCES_COMMANDS         INSTANCES_COMMANDS

END-ENTRY

3IBEGIN-ENTRY-CLASS_COMMANDS

COMMAND_SUMMARY
  COOL_COMMANDS
    CLASS_COMMANDS

The following commands manipulate defclasses. 

PPDEFCLASS: Displays the text of a given defclass.
(ppdefclass <class-name>)

LIST-DEFCLASSES: Displays the list of all defclasses in the specified
                 module (or the current module if none specified).
(list-defclasses [<module-name>])

UNDEFCLASS: Deletes a defclass, all its subclasses, and all
            associated instances.
(undefclass <class-name>)

DESCRIBE-CLASS: Provides a verbose description of a class.
(describe-class <class-name>)

BROWSE-CLASSES: Provides a rudimentary display of the inheritance
                relationships between a class and all its subclasses.
(browse-classes [<class-name>])

END-ENTRY

3IBEGIN-ENTRY-MESSAGE-HANDLER_COMMANDS

COMMAND_SUMMARY
  COOL_COMMANDS
    MESSAGE-HANDLER_COMMANDS

The following commands manipulate defmessage-handlers. Note that
<handler-type> is defined as follows:

<handler-type> ::= around | before | primary | after

PPDEFMESSAGE-HANDLER: Displays the text of a given defmessage-handler.
(ppdefmessage-handler <class-name> <handler-name> [<handler-type>])

LIST-DEFMESSAGE-HANDLERS: Displays a list of all (or some) defmessage-
handlers.
(list-defmessage-handlers [<class-name> [<handler-name> [<handler-type>]]])

UNDEFMESSAGE-HANDLER: Deletes a defmessage-handler.
(undefmessage-handler <class-name> <handler-name> [<handler-type>])

PREVIEW-SEND: Displays a list of all the applicable message-handlers for
              a message sent to an instance of a particular class.
(preview-send <class-name> <message-name>)

END-ENTRY

3IBEGIN-ENTRY-DEFINSTANCES_COMMANDS

COMMAND_SUMMARY
  COOL_COMMANDS
    DEFINSTANCES_COMMANDS

The following commands manipulate definstances. 

PPDEFINSTANCES: Displays the text of a given definstances.
(ppdefinstances <definstances-name>)

LIST-DEFINSTANCES: Displays the list of all definstances in the specified
                   module (or the current module if none specified).
(list-definstances [<module-name>])

UNDEFINSTANCES: Deletes a definstances.
(undefinstances <definstances-name>)

END-ENTRY

3IBEGIN-ENTRY-INSTANCES_COMMANDS

COMMAND_SUMMARY
  COOL_COMMANDS
    INSTANCES_COMMANDS

The following commands manipulate instances of user-defined classes. 

INSTANCES: Displays a list of instances.
(instances [<module-name> [<class-name> [inherit]]])

PPINSTANCE: Prints the slots of the active instance when called from 
            within the body of a message-handler.
(ppinstance)

SAVE-INSTANCES: Saves all instances to the specified file.
(save-instances <file-name>)

LOAD-INSTANCES: Loads instances from the specified file.
(load-instances <file-name>)

RESTORE-INSTANCES: Loads instances from the specified file.
(restore-instances <file-name>)

END-ENTRY

2IBEGIN-ENTRY-DEFMODULE_COMMANDS

COMMAND_SUMMARY
  DEFMODULE_COMMANDS

The following commands manipulate defmodules.

PPDEFMODULE: Displays the text of a given defmodule.
(ppdefmodule <defmodule-name>)

LIST-DEFMODULES: Displays the list of all defmodules.
(list-defmodules)

SET-CURRENT-MODULE: Sets the current module.
(set-current-module <module-name>)

GET-CURRENT-MODULE: Returns the current module.
(get-current-module)

END-ENTRY

2IBEGIN-ENTRY-MEMORY_COMMANDS

COMMAND_SUMMARY
  MEMORY_COMMANDS
  
The following commands display CLIPS memory status information.

MEM-USED: Returns number of bytes of memory CLIPS is using.
(mem-used)

MEM-REQUESTS: Returns the number of times CLIPS has requested memory
              from the operating system.
(mem-requests)

RELEASE-MEM: Releases all free memory held internally by CLIPS by to
             the operating system. Returns the amount of memory freed.
(release-mem)

CONSERVE-MEM: Turns on or off the storage of information used for the
              save and pretty-print commands.
(conserve-mem <status>)
<status> ::= on | off

END-ENTRY

2IBEGIN-ENTRY-TEXT_PROCESSING_COMMANDS

COMMAND_SUMMARY
  TEXT_PROCESSING_COMMANDS
  
The following commands can be used by users to maintain their own
information system similar to the help facility.

FETCH: Loads the named file into the internal lookup table.
(fetch <file-name>)

PRINT-REGION: Looks up the specified entry in a particular file which has
              been previously loaded into the lookup table and prints the
              contents of that entry to the specified logical name.
(print-region <logical-name> <lookup-file> <topic-field>*)

TOSS: Unloads the named file from the internal lookup table.
(toss <file-name>)

END-ENTRY

1MBEGIN-ENTRY-INTEGRATED_EDITOR

INTEGRATED_EDITOR

CLIPS includes a fully integrated version of the full screen MicroEMACS 
editor. You may call the editor from CLIPS, compile full buffers or just 
sections of the editor (incremental compile), temporarily exit the editor back 
to CLIPS, or permanently exit the editor.  Since the editor is full screen, 
portions of it are highly machine dependent.  As it is currently set up, the 
editor will run on VAX VMS machines using VT100- or VT240-compatible 
terminals, UNIX systems which support TERMCAP, the IBM PC, and most IBM 
compatibles.

Subtopics: 
USING_THE_EDITOR           EXTENDED_COMMANDS
CONTROL_COMMANDS           META_COMMANDS                

END-ENTRY

2IBEGIN-ENTRY-USING_THE_EDITOR

INTEGRATED_EDITOR
  USING_THE_EDITOR

The editor may be called from CLIPS with the following command:

    (edit ["<file-name>"])

The file name is optional. If one is given, that file would be loaded.  If no 
file name is given, the editor is entered without loading a file.  Once in the 
file, all of the EMACS commands listed below are applicable.  To exit the 
editor and clear all buffers, use <Ctrl-Z> or <Ctrl-X><Ctrl-C>.  To 
temporarily exit the editor and retain the information in the buffers, use 
<Ctrl-X> Q.  To compile a rules section, mark a region and type 
<Ctrl-X><Ctrl-T>. To compile the entire buffer, use <Meta-T>. The editor can 
use extensive amounts of memory and a flag is available in clips.h to remove 
all of the editor code.

When using the editor on multiuser machines like the VAX or many UNIX 
environments, be careful with the control S and control Q commands; they could 
conflict with terminal XON/XOFF communications. All of the control S commands 
have a work around built into the editor. The save file command, normally 
<Ctrl-X><Ctrl-S>, is also <Meta> Z. The forward search command, normally 
<Ctrl-S>, is also <Meta> J. The control Q command is rarely needed in a CLIPS 
file and, therefore, has no substitute.

The following two special characters should be noted when using the editor.
  
 <del>                 Delete previous character.
                       (also <ctrl-H> on some terminals)
 <esc>                 Meta command prefix.
                       (also <ctrl-[> on some terminals)

END-ENTRY

2IBEGIN-ENTRY-CONTROL_COMMANDS

INTEGRATED_EDITOR
  CONTROL_COMMANDS
  
These commands are entered by pressing the control key along with the 
designated character.

 <ctrl-@>          Set mark at current position.
 <ctrl-A>          Move cursor to beginning of line.
 <ctrl-B>          Move cursor BACK one character.
 <ctrl-C>          Start a new interactive command shell.  Be careful!
 <ctrl-D>          DELETE character under cursor.
 <ctrl-E>          Move cursor to END of line.
 <ctrl-F>          Move cursor FORWARD one character.
 <ctrl-G>          Abort any command.
 <ctrl-H>          (backspace) delete previous character.
 <ctrl-I>          Insert a TAB.
 <ctrl-J>          Insert a CR-LF and indent next line.
 <ctrl-K>          KILL (delete) to end of line.
 <ctrl-L>          Redisplay screen.
 <ctrl-M>          Insert a CR-LF.
 <ctrl-N>          Move cursor to NEXT line.
 <ctrl-O>          OPEN a new line.
 <ctrl-P>          Move to PREVIOUS line.
 <ctrl-Q>          QUOTE the next character (insert the next character typed).
 <ctrl-R>          Reverse SEARCH.
 <ctrl-S>          Forward SEARCH (also <Meta-J>).
 <ctrl-T>          TRANSPOSE characters.
 <ctrl-U>          Enter repeat count for next command.
 <ctrl-V>          VIEW the next screen (scroll up one screen).
 <ctrl-W>          KILL region (all text between cursor and last mark set).
 <ctrl-X>          Extended command prefix - see below.
 <ctrl-Y>          YANK (undelete) last text killed.
 <ctrl-Z>          Quick save of file in current buffer (only) and exit.

END-ENTRY

2IBEGIN-ENTRY-EXTENDED_COMMANDS

INTEGRATED_EDITOR
  EXTENDED_COMMANDS
  
These commands are entered by first pressing the control key along with the 
'x' character and then pressing the designated character.

 <ctrl-X>(             Begin keyboard Macro.
 <ctrl-X>)             End keyboard Macro.
 <ctrl-X>!             Execute a single external command.
 <ctrl-X>=             Show current cursor column and line number.
 <ctrl-X>:             Go to a specific line number.
 <ctrl-X>1             Display current window only.
 <ctrl-X>2             Split the current window.
 <ctrl-X>B             Switch to a different BUFFER.
 <ctrl-X>E             EXECUTE keyboard Macro.
 <ctrl-X>F             Set FILL column.
 <ctrl-X>K             KILL a buffer (other than current buffer).
 <ctrl-X>M             MATCH parenthesis (or {} or []).
 <ctrl-X>N             Move to NEXT window.
 <ctrl-X>P             Move to PREVIOUS window.
 <ctrl-X>R             Global search and REPLACE (backwards).
 <ctrl-X>S             Global SEARCH and replace (forwards).
 <ctrl-X>Z             Enlarge current window by repeat count <ctrl-U> lines.

 <ctrl-X><ctrl-B>      Show active BUFFERS.
 <ctrl-X><ctrl-C>      Exit without saving buffers.
 <ctrl-X><ctrl-F>      FIND file.  Load if not already in buffer.
 <ctrl-X><ctrl-N>      Scroll current window up by repeat count lines.
 <ctrl-X><ctrl-P>      Scroll current window down by repeat count lines.
 <ctrl-X><ctrl-R>      RENAME file.  Change file name for buffer.
 <ctrl-X><ctrl-S>      SAVE (write) current buffer into its file.
 <ctrl-X><ctrl-V>      VISIT a file.  Read file and display in current window.
 <ctrl-X><ctrl-W>      WRITE buffer to file.  Option to change name of file.
 <ctrl-X><ctrl-Z>      Reduce current window by repeat count lines.

END-ENTRY

2IBEGIN-ENTRY-META_COMMANDS

INTEGRATED_EDITOR
  META_COMMANDS
  
These commands are entered by first pressing the meta key (Activated by <esc> 
or <ctrl-[>) and then pressing the designated character.
        
 <meta>!                Move current line to repeat count lines from top of
                        window.
 <meta>>                Move cursor to end of buffer.
 <meta><                Move cursor to beginning of buffer.
 <meta>.                Set mark.
 <meta>B                Move cursor BACK one word.
 <meta>C                CAPITALIZE first letter of word.
 <meta>D                DELETE next word.
 <meta>F                Move cursor FORWARD one word.
 <meta>J                SEARCH forward (same as <ctrl-S>).
 <meta>L                LOWERCASE (lowercase) next word.
 <meta>R                Query search and REPLACE (backwards).
 <meta>S                Query SEARCH and replace (forwards).
 <meta>U                UPPERCASE (uppercase) next word.
 <meta>V                VIEW the previous screen (scroll down one screen).
 <meta>W                COPY region into kill buffer.
 <meta>Z                SAVE current buffer into file (same as
                        <ctrl-X><ctrl-S>).
 <meta><del>            DELETE previous word.

END-ENTRY



